#ifndef _BST_H#define _BST_H#include <iostream>using namespace std;//****************************//Templated BST Classtemplate <class T>class BST;//****************************//BNode Class Declaration//****************************template<class T>class BNode{	T data;    BNode<T>* left;    BNode<T>* right;    BNode();    BNode(T d);    BNode(T d, BNode<T>* l, BNode<T>*r);        friend class BST<T>;};//****************************//BNode Class Implementation//****************************template <class T>BNode<T>::BNode():left(NULL), right(NULL){}template <class T>BNode<T>::BNode(T d):data(d), left(NULL), right(NULL){}template <class T>BNode<T>::BNode(T d, BNode* l, BNode*r):data(d), left(l), right(r){}//****************************//BST Class Declaration//****************************template <class T>class BST{	//Private Data Members    BNode<T>* root;    BNode<T>* cursor;        //Private Functions    void Terminator(BNode<T>* subroot);    BNode<T>* Minimum(BNode<T>* subroot)const;	BNode<T>* Maximum(BNode<T>* subroot)const;	BNode<T>* AssignHelper(BNode<T>* bstroot, BNode<T>* bstcursor);        bool InsertHelper(BNode<T>*& subroot, T item);	BNode<T>* RemoveHelper(BNode<T>* subroot,T item);    bool FindHelper(BNode<T>* subroot, T item)const;        void MoveLeftHelper();    void MoveRightHelper();        void PrintInOrderHelper(ostream& os, BNode<T>* subroot)const;    void PrintPostOrderHelper(ostream& os, BNode<T>* subroot)const;    void PrintPreOrderHelper(ostream& os, BNode<T>* subroot) const;public:	//Public Functions/Constructors    BST();    BST(BST<T>& bst);    BST<T>& operator=(const BST<T>& bst);    ~BST();        bool Insert(T item);    void Remove(T item);    bool Find(T item)const;        void Move(char op);	    void PrintInOrder()const;    void PrintPostOrder()const;    void PrintPreOrder() const;    void PrintItem()const;};//****************************//BST Class Implementation//****************************//****************************//BST Default Constructortemplate <class T>BST<T>::BST(){    root = NULL;    cursor =NULL;}//****************************//BST Copy Constructortemplate <class T>BST<T>::BST(BST<T>& bst){    if(bst.root != NULL){									//if the source contains nodes        root = new BNode<T>(bst.root->data);					//copy root data                BNode<T>* bstleft = bst.root->left;						//temp vars for source tree        BNode<T>* bstright = bst.root->right;        BNode<T>* bstcursor = bst.cursor;                root->left = AssignHelper(bstleft, bstcursor);			//Recurse down the left source tree, returning the copied source tree                root->right = AssignHelper(bstright, bstcursor);		//Recurse down the right source tree, returning the copied source tree    } else {												//if the source is empty        root = NULL;											//set root to NULL        cursor = NULL;											//set cursor to NULL    }}//****************************//BST Assignent Opperatortemplate<class T>BST<T>& BST<T>::operator=(const BST<T>& bst){    if(bst.root != NULL){									//if the source contains data        root = new BNode<T>(bst.root->data);					//copy root data                BNode<T>* bstleft = bst.root->left;						//temp vars for source tree        BNode<T>* bstright = bst.root->right;        BNode<T>* bstcursor = bst.cursor;                root->left = AssignHelper(bstleft, bstcursor);			//Recurse down the left source tree, returning the copied source tree                root->right = AssignHelper(bstright, bstcursor);		//Recurse down the right source tree, returning the copied source tree    } else {												//if the source is empty        root = NULL;											//set root to NULL        cursor = NULL;											//set cursor to NULL    }    return *this;										//return the newly copied tree}//****************************//Copy/Assign Helpertemplate <class T>BNode<T>* BST<T>::AssignHelper(BNode<T>* bstroot, BNode<T>* bstcursor){    if(bstroot == NULL)											//if the source root doesnt exist,        return NULL;												//return NULL (base case)    else {														//otherwise, if the root exists,        BNode<T>* temp = new BNode<T>(bstroot->data);				//create new node containing the data from the source root                temp->left = AssignHelper(bstroot->left,cursor);			//Recurse down the left source tree, returning the copied source tree                temp->right = AssignHelper(bstroot->right,cursor);			//Recurse down the right source tree, returning the copied source tree                if(bstroot == bstcursor)										//if the current source node is the cursor,            cursor = temp;												//update the new (copied) cursor                return temp;												//return the node    }}//****************************//BST Destructortemplate <class T>BST<T>::~BST(){	Terminator(root);		//destroy nodes	root = NULL;			//set data members to NULL	cursor = NULL;}//****************************//Terminatortemplate <class T>void BST<T>::Terminator(BNode<T>* subroot){	if(subroot){										//if we still have roots		Terminator(subroot->left);							//delete the left child		Terminator(subroot->right);							//delete the right child		cout << "Deleting: " << subroot->data << endl;		//output feedback		delete subroot;										//delete the root	}}//****************************//Minimum Helper Functiontemplate <class T>BNode<T>* BST<T>::Minimum(BNode<T>* subroot)const{     BNode<T>* min = subroot;        /* loop down to find the leftmost (minimum value) leaf */    while (min->left)    	min = min->left;        return min;}//****************************//Maximum Helper Functiontemplate <class T>BNode<T>* BST<T>::Maximum(BNode<T>* subroot)const{     BNode<T>* max = subroot;         /* loop down to find the rightmost (maximum value) leaf */    while (max->right)     	max = max->right;        return max;}//****************************//Insert Functiontemplate <class T>bool BST<T>::Insert(T item){    return InsertHelper(root, item);                 }//****************************//Insert Helpertemplate <class T>bool BST<T>::InsertHelper(BNode<T>*& subroot, T item){    if (subroot == NULL){							//if the root doesn't exist        subroot = new BNode<T>(item, NULL, NULL); 		//create new node containing the data        cursor = subroot;								//update the cursor        return subroot;									//return true    }    else if (item < subroot->data){					//if the item is less than the current node        return InsertHelper(subroot->left, item);		//recurse down the left subtree    }    else if (item > subroot->data){					//if the item is greater than the current node        return InsertHelper(subroot->right, item);		//recurse down the right subtree    }    else{											//if the item is equal to the current node        cout << "NO DUPES FOR YOU!!!" << endl;			//NO SOUP FOR YOU        return false;									//return false    } }//****************************//Remove Functiontemplate <class T>void BST<T>::Remove(T item){	root = RemoveHelper(root, item);	//remove the item	cursor = root;						//update the cursor}//****************************//Remove Helpertemplate <class T>BNode<T>* BST<T>::RemoveHelper(BNode<T>* subroot,T item){	if (subroot == NULL)											//Base case: subroot is null		return subroot;		if (item < subroot->data)										//if the item to be removed is less than the current node,		subroot->left = RemoveHelper(subroot->left, item);				//then the item resides in the left subtree		else if (item > subroot->data)									//if the item to be removed is greater than the current node,		subroot->right= RemoveHelper(subroot->right, item);				//then the item resides in the right subtree																		//otherwise, the item is equal to the current node,	else{															//so we've found the node to be removed			if (subroot->left == NULL ){									//if there is no left child,			BNode<T>* temp = subroot->right;								//temp var			delete subroot;													//delete the subroot			return temp;													//return the right child		}		else if (subroot->right == NULL){								//if there is no right child,			BNode<T>* temp = subroot->left;  								//temp var			delete subroot;													//delete the subroot			return temp;													//return the right child		}																		//otherwise, there are two children,		BNode<T>* temp = Minimum(subroot->right);						//and we must find in-order successor (minimum value in right subtree)		subroot->data = temp->data;										//copy data from succesor to the subroot		subroot->right = RemoveHelper(subroot->right, temp->data);		//remove the succesor from the right subtree	}   return subroot;}//****************************//Find (search) Functiontemplate <class T>bool BST<T>::Find(T item)const{	return FindHelper(root, item);}//****************************//Find Helpertemplate <class T>bool BST<T>::FindHelper(BNode<T>* subroot, T item)const{	if(subroot==NULL)								//if the root is NULL,		return false;									//return false (base case)		else if(item == subroot->data)					//if the item is equal to the root,		return true;									//return true (other base case)		else if(item > subroot->data)					//if the item is greater than the root,		return FindHelper(subroot->right, item);		//recurse down the right subtree		else											//if the item is less than the root,		return FindHelper(subroot->left, item);			//recurse down the left subtree}//****************************//Move Functiontemplate <class T>void BST<T>::Move(char op){   if (root != NULL){				//if the list is not empty   	switch(op){        //Move left        case '<':        	MoveLeftHelper();            break;                //Move Right        case '>':        	MoveRightHelper();            break;                //Move begining        case 'B':        case 'b':        	cursor = Minimum(root);		//cursor goes to the minimum value node of the whole tree            break;                //Move end        case 'E':        case 'e':        	cursor = Maximum(root);		//cursor goes to the maximum value node of the whole tree            break;    }   }   else		cout << "Empty Tree " << endl;   	    }//****************************//Move(left) helpertemplate <class T>void BST<T>::MoveLeftHelper(){	BNode<T>* subroot = root;							//temp vars	BNode<T>* predecessor = NULL;	    if(cursor->left)									//if the cursor has a left subtree,    	cursor = Maximum(cursor->left);						//the cursor goes to the Max value node in the left subtree (in-order predecessor)        else {												//if the cursor has no left subtree,    	while(true){										//loop until we find a predecessor	    	if(cursor->data < subroot->data){					//if the cursor data is less than the current node data,	    															//then the current node cannot possibly be a predecessor,	    		subroot = subroot->left;							//so we move to the left and do not update the predecessor	    				} else if(cursor->data > subroot->data){			//if the cursor data is greater than the current node data,	    		predecessor = subroot;								//then the current node MIGHT be a predecessor,	    		subroot = subroot->right;							//so we move to the right and update the predecessor	    				} else {											//if the cursor data is equal to the current node data,				break;												//we have reached the end of the tree so we break the loop,			}														//remembering the predecessor (or lack thereof) we found		}		if(predecessor)										//if we found a predecessor,			cursor = predecessor;								//then that's where the cursor goes to		else												//if we did not find a predecessor,			cursor = Maximum(root);								//then we are at the front of the list, so the cursor wraps around to the end	}}//****************************//Move(right) helpertemplate <class T>void BST<T>::MoveRightHelper(){	BNode<T>* subroot = root;						//temp vars	BNode<T>* successor = NULL;	if(cursor->right)								//if the cursor has a right subtree,    	cursor = Minimum(cursor->right);				//the cursor goes to the Min value node in the right subtree (in-order successor)        else {											//if the cursor has no right subtree,    	while(true){									//loop until we find a successor	    	if(cursor->data > subroot->data){				//if the cursor data is geater than the current node data,	    														//then the current node cannot possibly be a successor,				subroot = subroot->right;						//so we move to the right and do not update the successor						} else if(cursor->data < subroot->data){		//if the cursor data is less than the current node data,	    		successor = subroot;							//then the current node MIGHT be a successor,	    		subroot = subroot->left;						//so we move to the left and update the successor	    				} else {										//if the cursor data is equal to the current node data,				break;											//we have reached the end of the tree so we break the loop,			}													//remembering the successor (or lack thereof) we found		}		if(successor)									//if we found a successor,			cursor = successor;								//then that's where the cursor goes to		else											//if we did not find a successor,			cursor = Minimum(root);							//then we are at the end of the list, so the cursor wraps around to the front	}	    }//****************************//Print In-Order Functiontemplate <class T>void BST<T>::PrintInOrder()const{	cout << "[ ";    PrintInOrderHelper(cout, root);		//print the entire list enclosed in brackets 	cout << "]";}//****************************//Print In-Order Helpertemplate <class T>void BST<T>::PrintInOrderHelper(ostream& os, BNode<T>* subroot)const{    if(subroot != NULL){							//if the root exists        PrintInOrderHelper(os, subroot->left);			//Print the left subtree		if (subroot == cursor)			os << "[" << subroot->data <<  "] ";		//Print the root data (in brackets if it's the cursor)		else			os << subroot->data << " ";		PrintInOrderHelper(os, subroot->right);			//Print the right subtree    }}//****************************//Print Post-Order Functiontemplate <class T>void BST<T>::PrintPostOrder()const{	cout << "[ ";    PrintPostOrderHelper(cout, root);    cout << "]";}//****************************//Print Post-Order Helpertemplate <class T>void BST<T>::PrintPostOrderHelper(ostream& os, BNode<T>* subroot)const{	if(subroot != NULL){							//if the root exists        PrintPostOrderHelper(os, subroot->left);		//Print the left subtree        PrintPostOrderHelper(os, subroot->right);		//Print the right subtree        if (subroot == cursor)	          	os << "[" << subroot->data << "] ";			//Print the root data (in brackets if it's the cursor)    	else        	os << subroot->data << " ";    }}//****************************//Print Pre-Order Functiontemplate <class T>void BST<T>::PrintPreOrder()const{	cout << "[ ";    PrintPreOrderHelper(cout, root);    cout << "]";}//****************************//Print Pre-Order Helpertemplate <class T>void BST<T>::PrintPreOrderHelper(ostream& os, BNode<T>* subroot)const{    if(subroot != NULL){							//if the root exists    	if (subroot == cursor)     		os << "["  << subroot->data << "] ";		//Print the root data (in brackets if it's the cursor)    	else        	os << subroot->data << " ";                PrintPreOrderHelper(os, subroot->left);			//Print the left subtree        PrintPreOrderHelper(os, subroot->right);		//Print the right subtree    }}//****************************//Print Itemtemplate <class T>void BST<T>::PrintItem()const{	if(cursor)		cout << "[" << cursor->data << "]";		//print data at cursor in brackets	else		cout << "Empty Tree";}#endif